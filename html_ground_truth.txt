This is a raw text version of an html file that had a working version of the side by side display before porting leanblueprint to lean. It it meant to serve as a style guide for the port to lean.
source:
https://e-vergo.github.io/General_Crystallographic_Restriction/blueprint/sect0004.html#a0000000011

-------
<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Companion Matrices</title>
<link rel="next" href="sect0005.html" title="The Crystallographic Restriction Theorem" />
<link rel="prev" href="sect0003.html" title="Integer Matrix Orders" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class=" active current">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
  <span class="expand-toc">▼</span>
  <ul class="sub-toc-1 active">
     <li class="">
  <a href="sect0004.html#a0000000011"><span class="toc_ref">4.1</span> <span class="toc_entry">Definition and Basic Properties</span></a>
 </li>
<li class="">
  <a href="sect0004.html#a0000000012"><span class="toc_ref">4.2</span> <span class="toc_entry">Cyclotomic Companion Matrices</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class="">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000005">4 Companion Matrices</h1>
<p>Companion matrices provide a key construction for achieving specific orders via cyclotomic polynomials. </p>
<h1 id="a0000000011">4.1 Definition and Basic Properties</h1>
<div class="definition_thmwrapper sbs-container theorem-style-definition" id="companion-def">
  <div class="sbs-latex-column">
    <div class="definition_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">4.1.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#companion-def">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion" class="lean_decl">Crystallographic.companion</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="definition_thmcontent">
    <p>     The companion matrix \(C(p)\) of a monic polynomial \(p = X^n + a_{n-1}X^{n-1} + \cdots + a_0\) is the \(n \times n\) matrix with \(1\)s on the subdiagonal and \(-a_i\) in the last column: </p>
<div class="displaymath" id="a0000000038">
  \[ C(p) = \begin{pmatrix}  0 

&  0 

&  \cdots 

&  -a_0 

\\ 1 

&  0 

&  \cdots 

&  -a_1 

\\ \vdots 

&  \ddots 

& &  \vdots 

\\ 0 

&  \cdots 

&  1 

&  -a_{n-1} 

\end{pmatrix} \]
</div>
<p> This construction produces a matrix whose characteristic polynomial equals \(p\), providing a canonical matrix realization for any monic polynomial. </p>

    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","1":"<code>R[X]</code>","10":"<code>Matrix.of.{v, u_2, u_3} {m : Type u_2} {n : Type u_3} {α : Type v} : (m → n → α) ≃ Matrix m n α</code><span class=\"sep\"></span><code class=\"docstring\">Cast a function into a matrix.\n\nThe two sides of the equivalence are definitionally equal types. We want to use an explicit cast\nto distinguish the types because `Matrix` has different instances to pi types (such as `Pi.mul`,\nwhich performs elementwise multiplication, vs `Matrix.mul`).\n\nIf you are defining a matrix, in terms of its entries, use `of (fun i j ↦ _)`. The\npurpose of this approach is to ensure that terms of the form `(fun i j ↦ _) * (fun i j ↦ _)` do not\nappear, as the type of `*` can be misleading.\n</code>","11":"<code>Fin p.natDegree</code>","12":"<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>","13":"<code>Fin.val {n : ℕ} (self : Fin n) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The number that is strictly less than `n`.\n\n`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.\n</code>","14":"<code>R</code>","15":"<code>Polynomial.coeff.{u} {R : Type u} [Semiring R] : R[X] → ℕ → R</code><span class=\"sep\"></span><code class=\"docstring\">`coeff p n` (often denoted `p.coeff n`) is the coefficient of `X^n` in `p`. </code>","2":"<code>Type u_1</code>","3":"<code>p.Monic</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>Matrix.{u, u&#39;, v} (m : Type u) (n : Type u&#39;) (α : Type v) : Type (max u u&#39; v)</code><span class=\"sep\"></span><code class=\"docstring\">`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`\nand whose columns are indexed by `n`. </code>","9":"<code>Fin (n : ℕ) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2162">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="0">companion</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="2">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.64" data-verso-hover="3">_hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.Monic" data-verso-hover="4">Monic</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.156" data-verso-hover="5">_hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="6">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Matrix" data-verso-hover="8">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin" data-verso-hover="9">Fin</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin" data-verso-hover="9">Fin</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9" data-verso-hover="2">R</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="const token" data-binding="const-Matrix.of" data-verso-hover="10">Matrix.of</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2293">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.290" data-verso-hover="11">i</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.293" data-verso-hover="11">j</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2308" data-verso-hover="12">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.293" data-verso-hover="11">j</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Fin.val" data-verso-hover="13">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="6">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.290" data-verso-hover="11">i</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Fin.val" data-verso-hover="13">val</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2308" data-verso-hover="12">then</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="14">1</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2308" data-verso-hover="12">else</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2345" data-verso-hover="12">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.293" data-verso-hover="11">j</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Fin.val" data-verso-hover="13">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="6">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2345" data-verso-hover="12">then</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="var token" data-binding="var-_uniq.56" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.coeff" data-verso-hover="15">coeff</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.290" data-verso-hover="11">i</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Fin.val" data-verso-hover="13">val</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2345" data-verso-hover="12">else</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="14">0</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L46-L74" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>

<p>The characteristic polynomial of the companion matrix is exactly the defining polynomial, and by the Cayley-Hamilton theorem, \(C_p\) satisfies \(p(C_p) = 0\). This makes companion matrices ideal for constructing matrices with prescribed minimal polynomials. </p>
<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:companion-aeval-zero">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.1.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#lem:companion-aeval-zero">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000039"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.1.2</a></li>
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.1.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion_aeval_eq_zero" class="lean_decl">Crystallographic.companion_aeval_eq_zero</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       \(p(C(p)) = 0\) (Cayley-Hamilton). By the Cayley-Hamilton theorem, every matrix satisfies its characteristic polynomial. Since the characteristic polynomial of \(C(p)\) is exactly \(p\) (by <span class="ttfamily">companion_charpoly</span>), we have \(p(C(p)) = 0\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000039">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> By Cayley-Hamilton, every matrix satisfies its characteristic polynomial. Since \(\chi _{C(p)} = p\) by the companion characteristic polynomial theorem, we have \(p(C(p)) = 0\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0</code>","1":"<code>R[X]</code>","10":"<code>Matrix (Fin p.natDegree) (Fin p.natDegree) R</code>","11":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","2":"<code>Type u_1</code>","3":"<code>p.Monic</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A</code><span class=\"sep\"></span><code class=\"docstring\">Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is\nthe unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.\n\nThis is a stronger variant of the linear map `Polynomial.leval`. </code>","9":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>", "0":"<code>Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0</code>","1":"<code>R[X]</code>","10":"<code>Matrix (Fin p.natDegree) (Fin p.natDegree) R</code>","11":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","12":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition&#39;s value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","13":"<code>Lean.Meta.Grind.AC.DiseqCnstr.h (self : Lean.Meta.Grind.AC.DiseqCnstr) : Lean.Meta.Grind.AC.DiseqCnstrProof</code>","14":"<code>Matrix.aeval_self_charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n]\n  (M : Matrix n n R) : (aeval M) M.charpoly = 0</code><span class=\"sep\"></span><code class=\"docstring\">The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,\napplied to the matrix itself, is zero.\n\nThis holds over any commutative ring.\n\nSee `LinearMap.aeval_self_charpoly` for the equivalent statement about endomorphisms.\n</code>","15":"<code>Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p (self : Lean.Meta.Grind.Arith.Cutsat.EqCnstr) : Int.Linear.Poly</code>","16":"<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>","17":"<code>Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :\n  (companion p hp hn).charpoly = p</code><span class=\"sep\"></span><code class=\"docstring\">The characteristic polynomial of the companion matrix equals the original polynomial.\n\nThis is the fundamental property of companion matrices: they are constructed precisely\nso that their characteristic polynomial matches the given monic polynomial.\n\nThe proof proceeds by strong induction on the degree n. For degree 1, direct computation\nshows both sides equal X + C(a_0). For degree n+1, Laplace expansion along the first\ncolumn gives a recurrence matching the polynomial structure.\n</code>","18":"<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* &#39;empty&#39; is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>","2":"<code>Type u_1</code>","3":"<code>p.Monic</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A</code><span class=\"sep\"></span><code class=\"docstring\">Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is\nthe unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.\n\nThis is a stronger variant of the linear map `Polynomial.leval`. </code>","9":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-28755">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_aeval_eq_zero" data-verso-hover="0">companion_aeval_eq_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.18831" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18784" data-verso-hover="2">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.18839" data-verso-hover="3">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18831" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.Monic" data-verso-hover="4">Monic</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.18891" data-verso-hover="5">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="6">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18831" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Polynomial.aeval" data-verso-hover="8">aeval</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="9">companion</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18831" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18839" data-verso-hover="3">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18891" data-verso-hover="5">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18831" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="10">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-28877" data-verso-hover="11">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-28882" data-verso-hover="12">have</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.AC.DiseqCnstr.h" data-verso-hover="13">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.aeval_self_charpoly" data-verso-hover="14">aeval_self_charpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="9">companion</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="15">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRwa__-28934" data-verso-hover="16">rwa</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Crystallographic.companion_charpoly" data-verso-hover="17">companion_charpoly</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="15">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-28967" data-verso-hover="18">at</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.AC.DiseqCnstr.h" data-verso-hover="13">h</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L546-L557" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:companion-aeval-zero');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-charpoly">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.1.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-charpoly">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000040"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#companion-def">Definition 4.1.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion_charpoly" class="lean_decl">Crystallographic.companion_charpoly</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       The characteristic polynomial of the companion matrix \(C(p)\) equals \(p\): \(\chi _{C(p)} = p\). The proof proceeds by induction on the degree, using cofactor expansion along the first column. The key insight is that the minor structure reduces to smaller companion matrices, and the base case (degree 1) follows by direct computation.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000040">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the degree \(n\). For the base case \(n = 1\), direct computation gives \(\det (XI - C) = X + a_0\). For \(n {\gt} 1\), expand along the first column: the \((1,1)\) minor is the companion matrix of lower degree, and the \((2,1)\) minor contributes the constant term. The recurrence matches the polynomial coefficients. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :\n  (companion p hp hn).charpoly = p</code><span class=\"sep\"></span><code class=\"docstring\">The characteristic polynomial of the companion matrix equals the original polynomial.\n\nThis is the fundamental property of companion matrices: they are constructed precisely\nso that their characteristic polynomial matches the given monic polynomial.\n\nThe proof proceeds by strong induction on the degree n. For degree 1, direct computation\nshows both sides equal X + C(a_0). For degree n+1, Laplace expansion along the first\ncolumn gives a recurrence matching the polynomial structure.\n</code>","1":"<code>R[X]</code>","10":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","2":"<code>Type u_1</code>","3":"<code>p.Monic</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","9":"<code>Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :\n  R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The characteristic polynomial of a matrix `M` is given by $\\det (t I - M)$. </code>", "0":"<code>Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :\n  (companion p hp hn).charpoly = p</code><span class=\"sep\"></span><code class=\"docstring\">The characteristic polynomial of the companion matrix equals the original polynomial.\n\nThis is the fundamental property of companion matrices: they are constructed precisely\nso that their characteristic polynomial matches the given monic polynomial.\n\nThe proof proceeds by strong induction on the degree n. For degree 1, direct computation\nshows both sides equal X + C(a_0). For degree n+1, Laplace expansion along the first\ncolumn gives a recurrence matching the polynomial structure.\n</code>","1":"<code>R[X]</code>","10":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","11":"<code class=\"docstring\">The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n</code>","12":"<code>Std.Iterators.Types.StepSizeIterator.n.{w, w&#39;} {α : Type w} {m : Type w → Type w&#39;} {β : Type w}\n  (self : Std.Iterators.Types.StepSizeIterator α m β) : ℕ</code>","13":"<code>CommRing.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A commutative ring is a ring with commutative multiplication. </code>","14":"<code>Nat.exists_eq_succ_of_ne_zero {n : ℕ} : n ≠ 0 → ∃ k, n = k.succ</code>","15":"<code>LT.lt.ne&#39;.{u_1} {α : Type u_1} [Preorder α] {a b : α} (h : b &lt; a) : a ≠ b</code>","16":"<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x&#39; ih =&gt; tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n</code>","17":"<code>Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p (self : Lean.Meta.Grind.Arith.Cutsat.EqCnstr) : Int.Linear.Poly</code>","18":"<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>","19":"<code>Submodule.zero.{u, v} {R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] {module_M : Module R M}\n  (p : Submodule R M) : Zero ↥p</code>","2":"<code>Type u_1</code>","20":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","21":"<code>Crystallographic.companion_charpoly_of_natDegree_one.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (hdeg : p.natDegree = 1) : (companion p hp hn).charpoly = p</code><span class=\"sep\"></span><code class=\"docstring\">For a monic polynomial of degree 1, the characteristic polynomial of its companion\nmatrix equals the polynomial. Both sides equal `X + C(p.coeff 0)`. </code>","22":"<code>WithBot.succ.{u_1} {α : Type u_1} [Preorder α] [OrderBot α] [SuccOrder α] (a : WithBot α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The successor of `a : WithBot α` as an element of `α`. </code>","23":"<code>Std.Time.GenericFormat.DateBuilder.m✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Minute.Ordinal</code>","24":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition&#39;s value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","25":"<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n</code>","26":"<code>Std.Time.Modifier.A (presentation : Std.Time.Number) : Std.Time.Modifier</code><span class=\"sep\"></span><code class=\"docstring\">`A`: Millisecond of day (e.g., 1234).\n</code>","27":"<code>Fin (n : ℕ) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>","28":"<code>Lean.IR.ResetReuse.R (e : Lean.IR.FnBody) : Lean.IR.ResetReuse.M Lean.IR.FnBody</code>","29":"<code>Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}\n  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α</code><span class=\"sep\"></span><code class=\"docstring\">Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of\na matrix `M : Matrix m n α`, the matrix `M.submatrix r c : Matrix l o α` is defined\nby `(M.submatrix r c) i j = M (r i) (c j)` for `(i,j) : l × o`.\nNote that the total number of row and columns does not have to be preserved. </code>","3":"<code>p.Monic</code>","30":"<code>Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m</code><span class=\"sep\"></span><code class=\"docstring\">Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.\n\nIn other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.\n</code>","31":"<code>Std.Iterators.IterM.Equiv.symm.{w, w&#39;} {m : Type w → Type w&#39;} {α₁ α₂ β : Type w} [Monad m] [LawfulMonad m]\n  [Std.Iterators.Iterator α₁ m β] [Std.Iterators.Iterator α₂ m β] {ita : Std.IterM m β} {itb : Std.IterM m β}\n  (h : ita.Equiv itb) : itb.Equiv ita</code>","32":"<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>","33":"<code>Matrix.BlockTriangular.det.{v, u_1, u_3} {α : Type u_1} {m : Type u_3} {R : Type v} {M : Matrix m m R} {b : m → α}\n  [CommRing R] [DecidableEq m] [Fintype m] [DecidableEq α] [LinearOrder α] (hM : M.BlockTriangular b) :\n  M.det = ∏ a ∈ Finset.image b Finset.univ, (M.toSquareBlock b a).det</code>","34":"<code>Mathlib.Tactic.TermCongr.CongrResult.heq (res : Mathlib.Tactic.TermCongr.CongrResult) : Lean.MetaM Lean.Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns the proof that `lhs ≍ rhs`. Fails if the `CongrResult` is inapplicable.\nIf `pf? = none`, this returns the `rfl` proof. </code>","35":"<code>finCongr {n m : ℕ} (eq : n = m) : Fin n ≃ Fin m</code><span class=\"sep\"></span><code class=\"docstring\">The &#39;identity&#39; equivalence between `Fin m` and `Fin n` when `m = n`. </code>","36":"<code class=\"docstring\">Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don&#39;t match the variables will typically result in the introduction of anonymous hypotheses.\n</code>","37":"<code>Matrix.TransvectionStruct.i.{u₂, u_1} {n : Type u_1} {R : Type u₂} (self : TransvectionStruct n R) : n</code>","38":"<code>Matrix.TransvectionStruct.j.{u₂, u_1} {n : Type u_1} {R : Type u₂} (self : TransvectionStruct n R) : n</code>","39":"<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`&#39;s, where the `hᵢ`&#39;s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","40":"<code>Matrix.submatrix_apply.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}\n  (A : Matrix m n α) (r : l → m) (c : o → n) (i : l) (j : o) : A.submatrix r c i j = A (r i) (c j)</code>","41":"<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>","42":"<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>","43":"<code>Matrix.det_submatrix_equiv_self.{v, u_1, u_2} {m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m]\n  [Fintype m] {R : Type v} [CommRing R] (e : n ≃ m) (A : Matrix m m R) : (A.submatrix ⇑e ⇑e).det = A.det</code><span class=\"sep\"></span><code class=\"docstring\">Permuting rows and columns with the same equivalence does not change the determinant. </code>","44":"<code>Matrix.det_succ_column_zero.{v} {R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :\n  A.det = ∑ i, (-1) ^ ↑i * A i 0 * (A.submatrix i.succAbove Fin.succ).det</code><span class=\"sep\"></span><code class=\"docstring\">Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column 0. </code>","45":"<code>Crystallographic.companion_charmatrix_col_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])\n  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)) :\n  A 0 0 = X ∧ A 1 0 = -1 ∧ ∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0</code><span class=\"sep\"></span><code class=\"docstring\">The first column of the charmatrix of a companion matrix has `X` at position `(0,0)`,\n`-1` at position `(1,0)`, and `0` at all positions `(i,0)` for `i &gt;= 2`. </code>","46":"<code>Crystallographic.companion_charmatrix_laplace_col_zero.{u_1} {R : Type u_1} [CommRing R] (m : ℕ)\n  (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]) (hA00 : A 0 0 = X) (hA10 : A 1 0 = -1)\n  (hA_other : ∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0) :\n  ∑ i, (-1) ^ ↑i * A i 0 * (A.submatrix i.succAbove Fin.succ).det =\n    X * (A.submatrix (Fin.succAbove 0) Fin.succ).det + (A.submatrix (Fin.succAbove 1) Fin.succ).det</code><span class=\"sep\"></span><code class=\"docstring\">The Laplace expansion of a matrix along column 0 reduces to two terms when only\nentries at rows 0 and 1 are nonzero. This applies to the charmatrix of companion matrices\nbecause entries `A i 0 = 0` for all `i &gt;= 2`. </code>","47":"<code>Polynomial.X_mul_divX_add.{u} {R : Type u} [Semiring R] (p : R[X]) : X * p.divX + C (p.coeff 0) = p</code>","48":"<code>Crystallographic.companion_charmatrix_minor00_det.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])\n  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯))\n  (IH :\n    ∀ (q : R[X]) (hq : q.Monic) (hq_pos : 0 &lt; q.natDegree),\n      q.natDegree = m + 1 → (companion q hq hq_pos).charpoly = q) :\n  (A.submatrix (Fin.succAbove 0) Fin.succ).det = p.divX</code><span class=\"sep\"></span><code class=\"docstring\">The determinant of the (0,0)-minor of the charmatrix equals `p.divX`.\nThis follows because the minor equals the charmatrix of companion(p.divX), and we\napply the induction hypothesis for the characteristic polynomial theorem. </code>","49":"<code>Crystallographic.companion_charmatrix_minor10_det.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])\n  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)) :\n  (A.submatrix (Fin.succAbove 1) Fin.succ).det = C (p.coeff 0)</code><span class=\"sep\"></span><code class=\"docstring\">The determinant of the (1,0)-minor of the charmatrix equals `C(p.coeff 0)`.\nThis follows from Laplace expansion along row 0, where only the last column entry is nonzero. </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","9":"<code>Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :\n  R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The characteristic polynomial of a matrix `M` is given by $\\det (t I - M)$. </code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-26789">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_charpoly" data-verso-hover="0">companion_charpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.18665" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18618" data-verso-hover="2">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.18673" data-verso-hover="3">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18665" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.Monic" data-verso-hover="4">Monic</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.18725" data-verso-hover="5">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="6">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18665" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="8">companion</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18665" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18673" data-verso-hover="3">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18725" data-verso-hover="5">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Matrix.charpoly" data-verso-hover="9">charpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18665" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-26907" data-verso-hover="10">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-26912" data-verso-hover="11">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">⟨</span></span><span class="const token" data-binding="const-Std.Iterators.Types.StepSizeIterator.n" data-verso-hover="12">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn_eq</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">⟩</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∃</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.Types.StepSizeIterator.n" data-verso-hover="12">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">p.natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.Types.StepSizeIterator.n" data-verso-hover="12">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="13">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.exists_eq_succ_of_ne_zero" data-verso-hover="14">Nat.exists_eq_succ_of_ne_zero</span><span class="inter-text"> </span><span class="const token" data-binding="const-LT.lt.ne'" data-verso-hover="15">hn.ne'</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-27005" data-verso-hover="16">induction</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.Types.StepSizeIterator.n" data-verso-hover="12">n</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-27017">generalizing</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.inductionAlts-27032" data-verso-hover="18">with</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Submodule.zero" data-verso-hover="19">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-27049" data-verso-hover="20">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_charpoly_of_natDegree_one" data-verso-hover="21">companion_charpoly_of_natDegree_one</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn_eq</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-WithBot.succ" data-verso-hover="22">succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-27126" data-verso-hover="24">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">p.natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="13">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn_eq</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-27171" data-verso-hover="25">let</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.charpoly" data-verso-hover="9">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin" data-verso-hover="27">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="13">2</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin" data-verso-hover="27">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="13">2</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.IR.ResetReuse.R" data-verso-hover="28">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span>X<span class="lean-bracket-1">]</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
      </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="8">companion</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Matrix.submatrix" data-verso-hover="29">charmatrix.submatrix</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin.cast" data-verso-hover="30">Fin.cast</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.IterM.Equiv.symm" data-verso-hover="31">hdeg.symm</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin.cast" data-verso-hover="30">Fin.cast</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.IterM.Equiv.symm" data-verso-hover="31">hdeg.symm</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-27315" data-verso-hover="24">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_def</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="8">companion</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Matrix.submatrix" data-verso-hover="29">charmatrix.submatrix</span><span class="inter-text">
        </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin.cast" data-verso-hover="30">Fin.cast</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.IterM.Equiv.symm" data-verso-hover="31">hdeg.symm</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Fin.cast" data-verso-hover="30">Fin.cast</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.IterM.Equiv.symm" data-verso-hover="31">hdeg.symm</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-rfl" data-verso-hover="32">rfl</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-27435" data-verso-hover="24">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_det</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.BlockTriangular.det" data-verso-hover="33">A.det</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="8">companion</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Matrix.BlockTriangular.det" data-verso-hover="33">charmatrix.det</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27495" data-verso-hover="10">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-27504" data-verso-hover="24">have</span><span class="inter-text"> </span><span class="const token" data-binding="const-Mathlib.Tactic.TermCongr.CongrResult.heq" data-verso-hover="34">heq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="8">companion</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Matrix.submatrix" data-verso-hover="29">charmatrix.submatrix</span><span class="inter-text">
          </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-finCongr" data-verso-hover="35">finCongr</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.IterM.Equiv.symm" data-verso-hover="31">hdeg.symm</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-finCongr" data-verso-hover="35">finCongr</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Iterators.IterM.Equiv.symm" data-verso-hover="31">hdeg.symm</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-27615" data-verso-hover="10">by</span><span class="inter-text">
        </span><span class="keyword token" data-binding="kw-occ-Lean.Elab.Tactic.Ext.ext-27626" data-verso-hover="36">ext</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.TransvectionStruct.i" data-verso-hover="37">i</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.TransvectionStruct.j" data-verso-hover="38">j</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-27635" data-verso-hover="39">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-27640">only</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Matrix.submatrix_apply" data-verso-hover="40">Matrix.submatrix_apply</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-27671" data-verso-hover="41">rfl</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-27681" data-verso-hover="42">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Mathlib.Tactic.TermCongr.CongrResult.heq" data-verso-hover="34">heq</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.det_submatrix_equiv_self" data-verso-hover="43">Matrix.det_submatrix_equiv_self</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-27727" data-verso-hover="42">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Matrix.charpoly" data-verso-hover="9">Matrix.charpoly</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_det</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.det_succ_column_zero" data-verso-hover="44">Matrix.det_succ_column_zero</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
    <span class="lean-comment">-- Get column structure and apply Laplace simplification</span>
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-27854" data-verso-hover="11">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">⟨</span></span><span class="unknown token" data-binding="">hA00</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA10</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_other</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">⟩</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_charmatrix_col_zero" data-verso-hover="45">companion_charmatrix_col_zero</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_def</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-27949" data-verso-hover="42">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Crystallographic.companion_charmatrix_laplace_col_zero" data-verso-hover="46">companion_charmatrix_laplace_col_zero</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA00</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA10</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_other</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.X_mul_divX_add" data-verso-hover="47">Polynomial.X_mul_divX_add</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="unknown token" data-binding="">,</span><span class="inter-text">
      </span><span class="const token" data-binding="const-Crystallographic.companion_charmatrix_minor00_det" data-verso-hover="48">companion_charmatrix_minor00_det</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_def</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="unknown token" data-binding="">,</span><span class="inter-text">
      </span><span class="const token" data-binding="const-Crystallographic.companion_charmatrix_minor10_det" data-verso-hover="49">companion_charmatrix_minor10_det</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="23">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="26">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_def</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L501-L542" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-charpoly');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-pow-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.1.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-pow-dvd">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000041"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#lem:companion-aeval-zero">Theorem 4.1.1</a></li>
          
          <li><a href="sect0004.html#lem:companion-aeval-zero">Theorem 4.1.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion_pow_eq_one_of_dvd" class="lean_decl">Crystallographic.companion_pow_eq_one_of_dvd</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(p \mid X^m - 1\), then \(C(p)^m = I\). If \(p \mid X^m - 1\), write \(X^m - 1 = p \cdot q\) for some \(q\). Since \(p(C(p)) = 0\), evaluating at \(C(p)\) gives \((X^m - 1)(C(p)) = p(C(p)) \cdot q(C(p)) = 0\), so \(C(p)^m - I = 0\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000041">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> If \(p \mid X^m - 1\), write \(X^m - 1 = p \cdot q\) for some polynomial \(q\). Evaluating at \(C(p)\): \((X^m - 1)(C(p)) = p(C(p)) \cdot q(C(p)) = 0 \cdot q(C(p)) = 0\), so \(C(p)^m = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1</code>","1":"<code>R[X]</code>","10":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","11":"<code>Matrix (Fin p.natDegree) (Fin p.natDegree) R</code>","12":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","2":"<code>Type u_1</code>","3":"<code>p.Monic</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>p ∣ X ^ m - 1</code>","9":"<code>Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">`X` is the polynomial variable (aka indeterminate). </code>", "0":"<code>Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1</code>","1":"<code>R[X]</code>","10":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","11":"<code>Matrix (Fin p.natDegree) (Fin p.natDegree) R</code>","12":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","13":"<code class=\"docstring\">The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n</code>","14":"<code>Verso.Output.instQuoteHtmlMkStr1.q : Verso.Output.Html → Lean.TSyntax `term</code>","15":"<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n</code>","16":"<code>Std.Time.Modifier.A (presentation : Std.Time.Number) : Std.Time.Modifier</code><span class=\"sep\"></span><code class=\"docstring\">`A`: Millisecond of day (e.g., 1234).\n</code>","17":"<code>Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p (self : Lean.Meta.Grind.Arith.Cutsat.EqCnstr) : Int.Linear.Poly</code>","18":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition&#39;s value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","19":"<code>Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A</code><span class=\"sep\"></span><code class=\"docstring\">Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is\nthe unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.\n\nThis is a stronger variant of the linear map `Polynomial.leval`. </code>","2":"<code>Type u_1</code>","20":"<code>CommRing.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A commutative ring is a ring with commutative multiplication. </code>","21":"<code>Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0</code>","22":"<code>Std.Time.GenericFormat.DateBuilder.m✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Minute.Ordinal</code>","23":"<code>Lean.IR.ResetReuse.R (e : Lean.IR.FnBody) : Lean.IR.ResetReuse.M Lean.IR.FnBody</code>","24":"<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>","25":"<code>Polynomial.aeval_mul.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] {p q : R[X]} (x : A) :\n  (aeval x) (p * q) = (aeval x) p * (aeval x) q</code>","26":"<code>Matrix.zero_mul.{v, u_1, u_2, u_3} {l : Type u_1} {m : Type u_2} {n : Type u_3} {α : Type v}\n  [NonUnitalNonAssocSemiring α] [Fintype m] (M : Matrix m n α) : 0 * M = 0</code>","27":"<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`&#39;s, where the `hᵢ`&#39;s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>","28":"<code>map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]\n  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b</code><span class=\"sep\"></span><code class=\"docstring\">Additive group homomorphisms preserve subtraction. </code>","29":"<code>map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]\n  [MonoidHomClass F G H] (f : F) (a : G) (n : ℕ) : f (a ^ n) = f a ^ n</code><span class=\"sep\"></span><code class=\"docstring\">See note [hom simp lemma priority] </code>","3":"<code>p.Monic</code>","30":"<code>Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :\n  (aeval x) X = x</code>","31":"<code>map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]\n  (f : F) : f 1 = 1</code><span class=\"sep\"></span><code class=\"docstring\">See note [hom simp lemma priority] </code>","32":"<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* &#39;empty&#39; is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>","33":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","34":"<code>Filter.Frequently.mp.{u} {α : Type u} {p q : α → Prop} {f : Filter α} (h : ∃ᶠ (x : α) in f, p x)\n  (hpq : ∀ᶠ (x : α) in f, p x → q x) : ∃ᶠ (x : α) in f, q x</code>","4":"<code>Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">a polynomial is `Monic` if its leading coefficient is 1 </code>","5":"<code>0 &lt; p.natDegree</code>","6":"<code>ℕ</code>","7":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","8":"<code>p ∣ X ^ m - 1</code>","9":"<code>Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">`X` is the polynomial variable (aka indeterminate). </code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-29522">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_pow_eq_one_of_dvd" data-verso-hover="0">companion_pow_eq_one_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.19541" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19494" data-verso-hover="2">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.19549" data-verso-hover="3">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19541" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.Monic" data-verso-hover="4">Monic</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="5">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="6">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19541" data-verso-hover="1">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="7">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.19603" data-verso-hover="6">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.19880" data-verso-hover="8">hdvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19541" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.X" data-verso-hover="9">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19603" data-verso-hover="6">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">1</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="10">companion</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19541" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19549" data-verso-hover="3">hp</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19601" data-verso-hover="5">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.19603" data-verso-hover="6">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="11">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-29683" data-verso-hover="12">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  <span class="lean-comment">-- From hdvd, get q such that X^m - 1 = p * q</span>
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-29736" data-verso-hover="13">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">⟨</span></span><span class="const token" data-binding="const-Verso.Output.instQuoteHtmlMkStr1.q" data-verso-hover="14">q</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">⟩</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd</span><span class="inter-text">
  <span class="lean-comment">-- Let A = companion p</span>
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-29790" data-verso-hover="15">let</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="16">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="10">companion</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
  <span class="lean-comment">-- We have aeval A p = 0 by companion_aeval_eq_zero</span>
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-29873" data-verso-hover="18">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval" data-verso-hover="19">aeval</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="16">A</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="20">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_aeval_eq_zero" data-verso-hover="21">companion_aeval_eq_zero</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Grind.Arith.Cutsat.EqCnstr.p" data-verso-hover="17">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
  <span class="lean-comment">-- Therefore aeval A </span><span class="lean-bracket-1">(</span>X^m - 1<span class="lean-bracket-1">)</span> = aeval A <span class="lean-bracket-1">(</span>p * q<span class="lean-bracket-1">)</span> = aeval A p * aeval A q = 0
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-30018" data-verso-hover="18">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hXm1_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval" data-verso-hover="19">aeval</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="16">A</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.X" data-verso-hover="9">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="22">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-CommRing" data-verso-hover="20">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.IR.ResetReuse.R" data-verso-hover="23">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="20">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-30071" data-verso-hover="12">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-30078" data-verso-hover="24">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="unknown token" data-binding="">hq</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval_mul" data-verso-hover="25">aeval_mul</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp_zero</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix.zero_mul" data-verso-hover="26">zero_mul</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
  <span class="lean-comment">-- But aeval A </span><span class="lean-bracket-1">(</span>X^m - 1<span class="lean-bracket-1">)</span> = A^m - 1
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-30155" data-verso-hover="18">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">haeval</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval" data-verso-hover="19">aeval</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="16">A</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.X" data-verso-hover="9">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="22">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-CommRing" data-verso-hover="20">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.IR.ResetReuse.R" data-verso-hover="23">R</span><span class="unknown token" data-binding=""><span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Std.Time.Modifier.A" data-verso-hover="16">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="22">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="const token" data-binding="const-CommRing" data-verso-hover="20">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-30213" data-verso-hover="12">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-30220" data-verso-hover="27">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-30225">only</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-map_sub" data-verso-hover="28">map_sub</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-map_pow" data-verso-hover="29">map_pow</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval_X" data-verso-hover="30">aeval_X</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-map_one" data-verso-hover="31">map_one</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
  <span class="lean-comment">-- So A^m - 1 = 0, i.e., A^m = 1</span>
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-30304" data-verso-hover="24">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="unknown token" data-binding="">haeval</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-30316" data-verso-hover="32">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hXm1_zero</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-30331" data-verso-hover="33">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Filter.Frequently.mp" data-verso-hover="34">sub_eq_zero.mp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hXm1_zero</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L561-L586" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-pow-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>


<h1 id="a0000000012">4.2 Cyclotomic Companion Matrices</h1>
<p>For achieving finite order \(m\), we use the companion matrix of the \(m\)-th cyclotomic polynomial \(\Phi _m\). Since roots of \(\Phi _m\) are primitive \(m\)-th roots of unity, this companion matrix has order exactly \(m\). </p>

<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:companion-cycl-pow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.2.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#lem:companion-cycl-pow">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000042"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-pow-dvd">Theorem 4.1.3</a></li>
          
          <li><a href="sect0004.html#thm:companion-pow-dvd">Theorem 4.1.3</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion_cyclotomic_pow_eq_one" class="lean_decl">Crystallographic.companion_cyclotomic_pow_eq_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       \(C(\Phi _m)^m = I\). Since the cyclotomic polynomial \(\Phi _m\) divides \(X^m - 1\) (as \(X^m - 1 = \prod _{d \mid m} \Phi _d\)), we apply <span class="ttfamily">companion_pow_eq_one_of_dvd</span>.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000042">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> Since \(\Phi _m \mid X^m - 1\) (as \(X^m - 1 = \prod _{d \mid m} \Phi _d\)), we apply the general companion power theorem to conclude \(C(\Phi _m)^m = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1</code>","1":"<code>ℕ</code>","2":"<code>0 &lt; (cyclotomic m ℤ).natDegree</code>","3":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","4":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","5":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","6":"<code>Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic</code><span class=\"sep\"></span><code class=\"docstring\">`cyclotomic n` is monic. </code>","7":"<code>Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ</code>","8":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>", "0":"<code>Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1</code>","1":"<code>ℕ</code>","10":"<code>Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)\n  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1</code>","11":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","12":"<code>Polynomial.cyclotomic.dvd_X_pow_sub_one.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : cyclotomic n R ∣ X ^ n - 1</code>","13":"<code>Std.Time.GenericFormat.DateBuilder.m✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Minute.Ordinal</code>","2":"<code>0 &lt; (cyclotomic m ℤ).natDegree</code>","3":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","4":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","5":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","6":"<code>Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic</code><span class=\"sep\"></span><code class=\"docstring\">`cyclotomic n` is monic. </code>","7":"<code>Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ</code>","8":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","9":"<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`&#39;s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-1574">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_pow_eq_one" data-verso-hover="0">companion_cyclotomic_pow_eq_one</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.68" data-verso-hover="2">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="3">cyclotomic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="4">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="5">companion</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="3">cyclotomic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic.monic" data-verso-hover="6">cyclotomic.monic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.68" data-verso-hover="2">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="7">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1742" data-verso-hover="8">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-1747" data-verso-hover="9">apply</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_pow_eq_one_of_dvd" data-verso-hover="10">companion_pow_eq_one_of_dvd</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-1783" data-verso-hover="11">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.cyclotomic.dvd_X_pow_sub_one" data-verso-hover="12">cyclotomic.dvd_X_pow_sub_one</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="13">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L39-L50" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:companion-cycl-pow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-cycl-order">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.2.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-cycl-order">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000043"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#lem:companion-cycl-pow">Theorem 4.2.1</a></li>
          
          <li><a href="sect0004.html#lem:companion-aeval-zero">Theorem 4.1.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.1.2</a></li>
          
          <li><a href="sect0004.html#lem:companion-cycl-pow">Theorem 4.2.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion_cyclotomic_orderOf" class="lean_decl">Crystallographic.companion_cyclotomic_orderOf</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       \(\mathrm{ord}(C(\Phi _m)) = m\) for \(m \geq 2\). The order is exactly \(m\) because: (1) \(\Phi _m \mid X^m - 1\) implies \(C(\Phi _m)^m = I\), and (2) if \(C(\Phi _m)^d = I\) for \(d {\lt} m\), then \(\Phi _m\) would divide \(X^d - 1\), contradicting that primitive \(m\)-th roots of unity are not \(d\)-th roots of unity for \(d {\lt} m\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000043">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> The order is at most \(m\) since \(\Phi _m \mid X^m - 1\) implies \(C(\Phi _m)^m = I\). For the lower bound: if \(C(\Phi _m)^d = I\) for \(d {\lt} m\), then \(\Phi _m \mid X^d - 1\), but this contradicts that primitive \(m\)-th roots of unity are not \(d\)-th roots. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m</code>","1":"<code>ℕ</code>","2":"<code>2 ≤ m</code>","3":"<code>0 &lt; (cyclotomic m ℤ).natDegree</code>","4":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","5":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","6":"<code>orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.\nOtherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. </code>","7":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","8":"<code>Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic</code><span class=\"sep\"></span><code class=\"docstring\">`cyclotomic n` is monic. </code>","9":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>", "0":"<code>Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m</code>","1":"<code>ℕ</code>","10":"<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n</code>","11":"<code>Std.Time.GenericFormat.DateBuilder.A✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Millisecond.Offset</code>","12":"<code>Std.Time.GenericFormat.DateBuilder.m✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Minute.Ordinal</code>","13":"<code>FixedPoints.minpoly.monic.{u, v} (G : Type u) [Group G] (F : Type v) [Field F] [MulSemiringAction G F] [Fintype G]\n  (x : F) : (FixedPoints.minpoly G F x).Monic</code>","14":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition&#39;s value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","15":"<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>","16":"<code>Nat.lt_of_lt_of_le {n m k : ℕ} : n &lt; m → m ≤ k → n &lt; k</code>","17":"<code class=\"docstring\">Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `⁻¹` `^` and `%`\nover numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,\nand can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n</code>","18":"<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>","19":"<code>orderOf_eq_iff.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : ℕ} (h : 0 &lt; n) :\n  orderOf x = n ↔ x ^ n = 1 ∧ ∀ m &lt; n, 0 &lt; m → x ^ m ≠ 1</code>","2":"<code>2 ≤ m</code>","20":"<code class=\"docstring\">If the main goal&#39;s target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>","21":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","22":"<code>Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1</code>","23":"<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal&#39;s target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>","24":"<code>Lean.Elab.Do.DoElemCont.k (self : Lean.Elab.Do.DoElemCont) : Lean.Elab.Do.DoElabM Lean.Expr</code><span class=\"sep\"></span><code class=\"docstring\">The continuation to elaborate the `rest` of the block. </code>","25":"<code>Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A</code><span class=\"sep\"></span><code class=\"docstring\">Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is\nthe unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.\n\nThis is a stronger variant of the linear map `Polynomial.leval`. </code>","26":"<code>Polynomial.Splits.X.{u_1} {R : Type u_1} [Semiring R] : X.Splits</code>","27":"<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`&#39;s, where the `hᵢ`&#39;s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>","28":"<code>map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]\n  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b</code><span class=\"sep\"></span><code class=\"docstring\">Additive group homomorphisms preserve subtraction. </code>","29":"<code>map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]\n  [MonoidHomClass F G H] (f : F) (a : G) (n : ℕ) : f (a ^ n) = f a ^ n</code><span class=\"sep\"></span><code class=\"docstring\">See note [hom simp lemma priority] </code>","3":"<code>0 &lt; (cyclotomic m ℤ).natDegree</code>","30":"<code>MvPolynomial.aeval_X.{u, v, u_1} {R : Type u} {S₁ : Type v} {σ : Type u_1} [CommSemiring R] [CommSemiring S₁]\n  [Algebra R S₁] (f : σ → S₁) (s : σ) : (MvPolynomial.aeval f) (MvPolynomial.X s) = f s</code>","31":"<code>map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]\n  (f : F) : f 1 = 1</code><span class=\"sep\"></span><code class=\"docstring\">See note [hom simp lemma priority] </code>","32":"<code>sub_self.{u_1} {G : Type u_1} [AddGroup G] (a : G) : a - a = 0</code>","33":"<code>Lean.Meta.Match.MatchEqnsExtState.map (self : Lean.Meta.Match.MatchEqnsExtState) :\n  Lean.PHashMap Lean.Name Lean.Meta.Match.MatchEqns</code>","34":"<code>algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →+* A</code><span class=\"sep\"></span><code class=\"docstring\">Embedding `R →+* A` given by `Algebra` structure. </code>","35":"<code>Algebra.ofId.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →ₐ[R] A</code><span class=\"sep\"></span><code class=\"docstring\">`AlgebraMap` as an `AlgHom`. </code>","36":"<code>RingEquiv.mapMatrix.{u_2, u_11, u_12} {m : Type u_2} {α : Type u_11} {β : Type u_12} [Fintype m] [DecidableEq m]\n  [NonAssocSemiring α] [NonAssocSemiring β] (f : α ≃+* β) : Matrix m m α ≃+* Matrix m m β</code><span class=\"sep\"></span><code class=\"docstring\">The `RingEquiv` between spaces of square matrices induced by a `RingEquiv` between their\ncoefficients. This is `Matrix.map` as a `RingEquiv`. </code>","37":"<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>","38":"<code>Std.Do.SPred.Tactic.Focus.this.{u} {σs : List (Type u)} {P : Std.Do.SPred σs} : P ⊣⊢ₛ ⌜True⌝ ∧ P</code>","39":"<code>Polynomial.aeval_map_algebraMap.{u_1, u_2, u_3} {R : Type u_1} (A : Type u_2) {B : Type u_3} [CommSemiring R]\n  [CommSemiring A] [Semiring B] [Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B] (x : B) (p : R[X]) :\n  (aeval x) (map (algebraMap R A) p) = (aeval x) p</code>","4":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","40":"<code>Polynomial.aeval_algHom_apply.{u, z, u_2, u_3} {R : Type u} {A : Type z} {B : Type u_2} [CommSemiring R] [Semiring A]\n  [Semiring B] [Algebra R A] [Algebra R B] {F : Type u_3} [FunLike F A B] [AlgHomClass F R A B] (f : F) (x : A)\n  (p : R[X]) : (aeval (f x)) p = f ((aeval x) p)</code>","41":"<code>map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]\n  [ZeroHomClass F M N] (f : F) : f 0 = 0</code>","42":"<code>Polynomial.map_sub.{u, u_1} {R : Type u} [Ring R] {p q : R[X]} {S : Type u_1} [Ring S] (f : R →+* S) :\n  map f (p - q) = map f p - map f q</code>","43":"<code>Polynomial.map_pow.{u, v} {R : Type u} {S : Type v} [Semiring R] {p : R[X]} [Semiring S] (f : R →+* S) (n : ℕ) :\n  map f (p ^ n) = map f p ^ n</code>","44":"<code>Polynomial.map_X.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : map f X = X</code>","45":"<code>Polynomial.map_one.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : map f 1 = 1</code>","46":"<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* &#39;empty&#39; is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>","47":"<code>minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]</code><span class=\"sep\"></span><code class=\"docstring\">Suppose `x : B`, where `B` is an `A`-algebra.\n\nThe minimal polynomial `minpoly A x` of `x`\nis a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,\nif such exists (`IsIntegral A x`) or zero otherwise.\n\nFor example, if `V` is a `𝕜`-vector space for some field `𝕜` and `f : V →ₗ[𝕜] V` then\nthe minimal polynomial of `f` is `minpoly 𝕜 f`.\n</code>","48":"<code>minpoly.dvd.{u_1, u_2} (A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : A[X]}\n  (hp : (aeval x) p = 0) : minpoly A x ∣ p</code><span class=\"sep\"></span><code class=\"docstring\">If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`.\nSee also `minpoly.isIntegrallyClosed_dvd` which relaxes the assumptions on `A` in exchange for\nstronger assumptions on `B`. </code>","49":"<code>Crystallographic.companion_cyclotomic_minpoly (m : ℕ) (hm_pos : 0 &lt; m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  have A := companion (cyclotomic m ℤ) ⋯ hn;\n  have AQ := A.map ⇑(algebraMap ℤ ℚ);\n  minpoly ℚ AQ = cyclotomic m ℚ</code><span class=\"sep\"></span><code class=\"docstring\">For the companion matrix of cyclotomic m ℤ, the minimal polynomial over ℚ equals cyclotomic m ℚ.\nThis uses that minpoly | charpoly = cyclotomic, and cyclotomic is monic irreducible over ℚ. </code>","5":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","50":"<code>Nat.not_dvd_of_pos_of_lt {n m : ℕ} (h1 : 0 &lt; n) (h2 : n &lt; m) : ¬m ∣ n</code>","51":"<code>Crystallographic.dvd_of_cyclotomic_dvd_X_pow_sub_one (m k : ℕ) (hm_pos : 0 &lt; m) (hk_pos : 0 &lt; k)\n  (hdvd : cyclotomic m ℚ ∣ X ^ k - 1) : m ∣ k</code><span class=\"sep\"></span><code class=\"docstring\">If cyclotomic m ℚ divides X^k - 1 for 0 &lt; k, then m ∣ k.\nThis uses the factorization X^k - 1 = ∏_{d|k} Φ_d and that cyclotomic polynomials\nare coprime for different indices. </code>","6":"<code>orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.\nOtherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. </code>","7":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>","8":"<code>Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic</code><span class=\"sep\"></span><code class=\"docstring\">`cyclotomic n` is monic. </code>","9":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-5493">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_orderOf" data-verso-hover="0">companion_cyclotomic_orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.1905" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.1947" data-verso-hover="2">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1905" data-verso-hover="1">m</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2011" data-verso-hover="3">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1905" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="5">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-orderOf" data-verso-hover="6">orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="7">companion</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1905" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic.monic" data-verso-hover="8">cyclotomic.monic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1905" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2011" data-verso-hover="3">hn</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1905" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5679" data-verso-hover="9">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-5684" data-verso-hover="10">let</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.A" data-verso-hover="11">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="7">companion</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-FixedPoints.minpoly.monic" data-verso-hover="13">cyclotomic.monic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-5752" data-verso-hover="14">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.lt_of_lt_of_le" data-verso-hover="16">Nat.lt_of_lt_of_le</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5795" data-verso-hover="9">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.normNum-5798" data-verso-hover="17">norm_num</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">2</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-5821" data-verso-hover="18">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-orderOf_eq_iff" data-verso-hover="19">orderOf_eq_iff</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_pos</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-5850" data-verso-hover="20">constructor</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-5867" data-verso-hover="21">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_pow_eq_one" data-verso-hover="22">companion_cyclotomic_pow_eq_one</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-5915" data-verso-hover="23">intro</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Elab.Do.DoElemCont.k" data-verso-hover="24">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hAk</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-5941" data-verso-hover="14">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">haeval_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval" data-verso-hover="25">aeval</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.A" data-verso-hover="11">A</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.Splits.X" data-verso-hover="26">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Elab.Do.DoElemCont.k" data-verso-hover="24">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Nat" data-verso-hover="15">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5998" data-verso-hover="9">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-6007" data-verso-hover="27">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-6012">only</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-map_sub" data-verso-hover="28">map_sub</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-map_pow" data-verso-hover="29">map_pow</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-MvPolynomial.aeval_X" data-verso-hover="30">aeval_X</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-map_one" data-verso-hover="31">map_one</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-6060" data-verso-hover="18">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="unknown token" data-binding="">hAk</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-sub_self" data-verso-hover="32">sub_self</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
    <span class="lean-comment">-- Work over ℚ where cyclotomic is irreducible</span>
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-6136" data-verso-hover="10">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">AQ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.Match.MatchEqnsExtState.map" data-verso-hover="33">A.map</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-algebraMap" data-verso-hover="34">algebraMap</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6177" data-verso-hover="14">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">haeval_Q_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval" data-verso-hover="25">aeval</span><span class="inter-text"> </span><span class="unknown token" data-binding="">AQ</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.Splits.X" data-verso-hover="26">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Elab.Do.DoElemCont.k" data-verso-hover="24">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Meta.Match.MatchEqnsExtState.map" data-verso-hover="33">map</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-algebraMap" data-verso-hover="34">algebraMap</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6262" data-verso-hover="9">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6271" data-verso-hover="14">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">AQ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Algebra.ofId" data-verso-hover="35">Algebra.ofId</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-RingEquiv.mapMatrix" data-verso-hover="36">mapMatrix</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.A" data-verso-hover="11">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-rfl" data-verso-hover="37">rfl</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-6331" data-verso-hover="18">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Std.Do.SPred.Tactic.Focus.this" data-verso-hover="38">this</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval_map_algebraMap" data-verso-hover="39">aeval_map_algebraMap</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.aeval_algHom_apply" data-verso-hover="40">aeval_algHom_apply</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">haeval_zero</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-map_zero" data-verso-hover="41">map_zero</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-6410" data-verso-hover="27">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-6415">only</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="const token" data-binding="const-Polynomial.map_sub" data-verso-hover="42">Polynomial.map_sub</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.map_pow" data-verso-hover="43">Polynomial.map_pow</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.map_X" data-verso-hover="44">Polynomial.map_X</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.map_one" data-verso-hover="45">Polynomial.map_one</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6505" data-verso-hover="46">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">haeval_Q_zero</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6526" data-verso-hover="14">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-minpoly" data-verso-hover="47">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">AQ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.Splits.X" data-verso-hover="26">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Elab.Do.DoElemCont.k" data-verso-hover="24">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="15">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span></span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-minpoly.dvd" data-verso-hover="48">minpoly.dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">AQ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">haeval_Q_zero</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6619" data-verso-hover="14">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-minpoly" data-verso-hover="47">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">AQ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_minpoly" data-verso-hover="49">companion_cyclotomic_minpoly</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-6720" data-verso-hover="18">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="unknown token" data-binding="">hminpoly_eq</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6737" data-verso-hover="46">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd1</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-6750" data-verso-hover="21">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.not_dvd_of_pos_of_lt" data-verso-hover="50">Nat.not_dvd_of_pos_of_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Crystallographic.dvd_of_cyclotomic_dvd_X_pow_sub_one" data-verso-hover="51">dvd_of_cyclotomic_dvd_X_pow_sub_one</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="12">m</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Elab.Do.DoElemCont.k" data-verso-hover="24">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd1</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L110-L141" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-cycl-order');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:mem-orders-totient">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.2.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:mem-orders-totient">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000044"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-cycl-mem">Theorem 4.2.4</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-mem">Theorem 4.2.4</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.mem_integerMatrixOrders_totient" class="lean_decl">Crystallographic.mem_integerMatrixOrders_totient</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       For \(m \geq 2\), \(m \in \mathrm{Ord}_{\varphi (m)}\). This is the key existence result: for every \(m \geq 2\), there exists an integer matrix of dimension \(\varphi (m)\) with multiplicative order exactly \(m\), namely the companion matrix of \(\Phi _m\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000044">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> Apply the cyclotomic companion membership theorem after noting that \(\deg (\Phi _m) = \varphi (m)\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.mem_integerMatrixOrders_totient (m : ℕ) (hm : 2 ≤ m) : m ∈ integerMatrixOrders m.totient</code>","1":"<code>ℕ</code>","2":"<code>2 ≤ m</code>","3":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","4":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler&#39;s totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>","5":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>", "0":"<code>Crystallographic.mem_integerMatrixOrders_totient (m : ℕ) (hm : 2 ≤ m) : m ∈ integerMatrixOrders m.totient</code>","1":"<code>ℕ</code>","10":"<code>Polynomial.natDegree_cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] :\n  (cyclotomic n R).natDegree = n.totient</code><span class=\"sep\"></span><code class=\"docstring\">The natural degree of `cyclotomic n` is `totient n`. </code>","11":"<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>","12":"<code>Lean.Meta.LibrarySearch.DeclMod.mpr : Lean.Meta.LibrarySearch.DeclMod</code><span class=\"sep\"></span><code class=\"docstring\">the backward direction of an `iff` </code>","13":"<code class=\"docstring\">The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n</code>","14":"<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>","15":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","16":"<code>Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)\n  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree</code>","2":"<code>2 ≤ m</code>","3":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","4":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler&#39;s totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>","5":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","6":"<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition&#39;s value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>","7":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","8":"<code>Std.Time.GenericFormat.DateBuilder.m✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Minute.Ordinal</code>","9":"<code>Polynomial.MonicDegreeEq.natDegree.{u} {R : Type u} {n : ℕ} [Semiring R] [Nontrivial R] (p : MonicDegreeEq R n) :\n  (↑p).natDegree = n</code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-8226">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.mem_integerMatrixOrders_totient" data-verso-hover="0">mem_integerMatrixOrders_totient</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2475" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2517" data-verso-hover="2">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2475" data-verso-hover="1">m</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2475" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="3">Crystallographic.integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="4">Nat.totient</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2475" data-verso-hover="1">m</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8359" data-verso-hover="5">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-8364" data-verso-hover="6">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="7">cyclotomic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="8">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.MonicDegreeEq.natDegree" data-verso-hover="9">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="4">Nat.totient</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="8">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Polynomial.natDegree_cyclotomic" data-verso-hover="10">Polynomial.natDegree_cyclotomic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="8">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-8464" data-verso-hover="6">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">htot_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="11">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="4">Nat.totient</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="8">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Lean.Meta.LibrarySearch.DeclMod.mpr" data-verso-hover="12">Nat.totient_pos.mpr</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8522" data-verso-hover="5">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-8525" data-verso-hover="13">omega</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-8534" data-verso-hover="6">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="11">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="7">cyclotomic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="8">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.MonicDegreeEq.natDegree" data-verso-hover="9">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8580" data-verso-hover="5">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-8583" data-verso-hover="13">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-8591" data-verso-hover="14">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">[</span></span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">]</span></span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-8607" data-verso-hover="15">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_mem_integerMatrixOrders" data-verso-hover="16">companion_cyclotomic_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="8">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L160-L173" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:mem-orders-totient');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-cycl-mem">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.2.4</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-cycl-mem">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000045"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-cycl-order">Theorem 4.2.2</a></li>
          
          <li><a href="sect0004.html#companion-def">Definition 4.1.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-order">Theorem 4.2.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://github.com/e-vergo/General_Crystallographic_Restriction/tree/main/Crystallographic/find/#doc/Crystallographic.companion_cyclotomic_mem_integerMatrixOrders" class="lean_decl">Crystallographic.companion_cyclotomic_mem_integerMatrixOrders</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       \(m \in \mathrm{Ord}_{\varphi (m)}\) via \(C(\Phi _m)\). Since \(\deg (\Phi _m) = \varphi (m)\), the companion matrix \(C(\Phi _m)\) is \(\varphi (m) \times \varphi (m)\) with integer entries, and has order exactly \(m\) by <span class="ttfamily">companion_cyclotomic_orderOf</span>.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000045">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> The companion matrix \(C(\Phi _m)\) witnesses the membership: it is an integer matrix of dimension \(\deg (\Phi _m) = \varphi (m)\) with multiplicative order exactly \(m\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)\n  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree</code>","1":"<code>ℕ</code>","2":"<code>2 ≤ m</code>","3":"<code>0 &lt; (cyclotomic m ℤ).natDegree</code>","4":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","5":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","6":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","7":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>", "0":"<code>Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)\n  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree</code>","1":"<code>ℕ</code>","10":"<code>Std.Time.GenericFormat.DateBuilder.m✝ (self : Std.Time.GenericFormat.DateBuilder✝) : Option Std.Time.Minute.Ordinal</code>","11":"<code>FixedPoints.minpoly.monic.{u, v} (G : Type u) [Group G] (F : Type v) [Field F] [MulSemiringAction G F] [Fintype G]\n  (x : F) : (FixedPoints.minpoly G F x).Monic</code>","12":"<code class=\"docstring\">If the main goal&#39;s target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>","13":"<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>","14":"<code>Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :\n  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m</code>","15":"<code class=\"docstring\">The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n</code>","2":"<code>2 ≤ m</code>","3":"<code>0 &lt; (cyclotomic m ℤ).natDegree</code>","4":"<code>Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th cyclotomic polynomial with coefficients in `R`. </code>","5":"<code>Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. </code>","6":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","7":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","8":"<code class=\"docstring\">`use e₁, e₂, ⋯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic\n`refine ⟨e₁, e₂, ⋯, ?_, ⋯, ?_⟩` with any number of placeholders (rather than just one) and\nthen trying to close goals associated to the placeholders with a configurable discharger (rather\nthan just `try trivial`).\n\nExamples:\n\n```lean\nexample : ∃ x : Nat, x = x := by use 42\n\nexample : ∃ x : Nat, ∃ y : Nat, x = y := by use 42, 42\n\nexample : ∃ x : String × String, x.1 = x.2 := by use (\"forty-two\", \"forty-two\")\n```\n\n`use! e₁, e₂, ⋯` is similar but it applies constructors everywhere rather than just for\ngoals that correspond to the last argument of a constructor. This gives the effect that\nnested constructors are being flattened out, with the supplied values being used along the\nleaves and nodes of the tree of constructors.\nWith `use!` one can feed in each `42` one at a time:\n\n```lean\nexample : ∃ p : Nat × Nat, p.1 = p.2 := by use! 42, 42\n\nexample : ∃ p : Nat × Nat, p.1 = p.2 := by use! (42, 42)\n```\n\nThe second line makes use of the fact that `use!` tries refining with the argument before\napplying a constructor. Also note that `use`/`use!` by default uses a tactic\ncalled `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since\n`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.\n\nThese tactics take an optional discharger to handle remaining explicit `Prop` constructor arguments.\nBy default it is `use (discharger := try with_reducible use_discharger) e₁, e₂, ⋯`.\nTo turn off the discharger and keep all goals, use `(discharger := skip)`.\nTo allow \"heavy refls\", use `(discharger := try use_discharger)`.\n</code>","9":"<code>Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :\n  Matrix (Fin p.natDegree) (Fin p.natDegree) R</code><span class=\"sep\"></span><code class=\"docstring\">The companion matrix of a monic polynomial p of degree n.\n\nFor p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:\n```\n[0  0  0  ...  0  -a_0    ]\n[1  0  0  ...  0  -a_1    ]\n[0  1  0  ...  0  -a_2    ]\n[        ...              ]\n[0  0  0  ...  1  -a_{n-1}]\n```\n\nThe matrix has 1s on the subdiagonal and the negatives of the polynomial\ncoefficients in the last column.\n</code>"}'><code class="hl lean lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-7422">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_mem_integerMatrixOrders" data-verso-hover="0">companion_cyclotomic_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2279" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2321" data-verso-hover="2">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2279" data-verso-hover="1">m</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text">
    </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="var token" data-binding="var-_uniq.2385" data-verso-hover="3">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-2">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2279" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-2">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="5">natDegree</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.2279" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="6">Crystallographic.integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2279" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Polynomial.natDegree" data-verso-hover="5">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7625" data-verso-hover="7">by</span></code><code class="hl lean lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.useSyntax-7630" data-verso-hover="8">use</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion" data-verso-hover="9">companion</span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-Polynomial.cyclotomic" data-verso-hover="4">cyclotomic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="10">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding=""><span class="lean-bracket-1">(</span></span><span class="const token" data-binding="const-FixedPoints.minpoly.monic" data-verso-hover="11">cyclotomic.monic</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="10">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding=""><span class="lean-bracket-1">)</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.constructor-7693" data-verso-hover="12">constructor</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-7710" data-verso-hover="13">exact</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.companion_cyclotomic_orderOf" data-verso-hover="14">companion_cyclotomic_orderOf</span><span class="inter-text"> </span><span class="const token" data-binding="const-_private.Std.Time.Format.Basic.0.Std.Time.GenericFormat.DateBuilder.m" data-verso-hover="10">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-7758" data-verso-hover="15">omega</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L145-L158" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-cycl-mem');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isCollapsed = icon && icon.textContent.trim() === '▶';
      // Use jQuery slideUp/slideDown to match LaTeX proof animation
      if (isCollapsed) {
        $(leanProofBody).slideUp(300);
      } else {
        $(leanProofBody).slideDown(300);
      }
    }, 50);
  });
})();
</script>



</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0003.html" title="Integer Matrix Orders"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="sect0005.html" title="The Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
<script type="text/javascript" src="js/popper.min.js"></script>
<script type="text/javascript" src="js/tippy-bundle.umd.min.js"></script>
<script type="text/javascript" src="js/verso-code.js"></script>
</body>
</html>