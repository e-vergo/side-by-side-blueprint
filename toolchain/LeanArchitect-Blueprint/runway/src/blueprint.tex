\documentclass{article}

\input{../../.lake/build/dressed/library/LeanArchitectBlueprint.tex}

\usepackage{amsmath, amsthm, amssymb}
\usepackage{hyperref}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{axiom}{Axiom}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}{Corollary}[section]

\title{LeanArchitect: The Blueprint Annotation System}
\author{Side-by-Side Blueprint Project}

\begin{document}
\maketitle

% =============================================================================
\chapter{Introduction}
% =============================================================================

LeanArchitect is a Lean 4 library that provides the \texttt{@[blueprint]}
attribute for annotating formal declarations with informal mathematical
descriptions, dependency metadata, and formalization status. It serves as the
foundation layer of the Side-by-Side Blueprint toolchain, which displays formal
Lean proofs alongside their corresponding LaTeX theorem statements.

The core problem LeanArchitect addresses is the gap between a formalization
project's informal mathematical narrative and its formal Lean code. In a
traditional workflow, these two representations evolve independently: the
mathematician writes a LaTeX document describing theorems and their logical
structure, while the proof engineer formalizes definitions and proofs in Lean.
LeanArchitect bridges this gap by embedding the informal narrative directly
into the Lean source as structured annotations, ensuring that the two
representations are coupled at the declaration level.

LeanArchitect's design is guided by three principles. First, annotations must
never interfere with compilation: all validation is advisory, producing warnings
rather than errors. Second, dependency information should be inferred from the
proof terms whenever possible, with manual overrides available for edge cases.
Third, the system must support the full spectrum of formalization progress, from
initial planning through to mathlib readiness, via a six-level status model
that drives visual feedback in the dependency graph.

This document is self-referential: LeanArchitect's \texttt{@[blueprint]}
attribute is used here to document LeanArchitect itself. The 79 annotated
declarations across 12 source modules are rendered inline using the same
machinery they define. The document you are reading was generated by the
Side-by-Side Blueprint system, with each formal declaration displayed alongside
the LaTeX description that its annotation carries.

% =============================================================================
\chapter{The \texttt{@[blueprint]} Attribute}
% =============================================================================

The \texttt{@[blueprint]} attribute is the user-facing entry point to
LeanArchitect. Attaching it to a Lean declaration registers that declaration as
a node in the blueprint graph, optionally with informal mathematical content,
dependency overrides, status flags, and project management metadata. This
chapter traces the full pipeline from attribute syntax through configuration
parsing to node construction.

\section{Configuration Structure}

The intermediate representation between parsed syntax and the final node is the
\texttt{Config} structure, which encodes all 24 user-facing options organized
into five categories: content, dependencies, status, presentation, and dashboard
metadata. Every field has a sensible default, so the minimal annotation
\texttt{@[blueprint "label"]} requires zero configuration.

\inputleannode{la:config}

The following accessor provides backwards compatibility for callers that predate
the six-status model and still use a boolean readiness check.

\inputleannode{la:config-not-ready}

\section{Dependency Parsing}

The \texttt{uses} and \texttt{proofUses} clauses of the attribute support a
four-way classification of dependency specifications. Each identifier is
resolved to a Lean constant name via \texttt{tryResolveConst}, while raw LaTeX
labels pass through as unchecked strings. Both namespaces support negation
syntax (\texttt{-name} or \texttt{-"label"}) for excluding auto-inferred
dependencies.

\inputleannode{la:elab-blueprint-uses}

\section{Configuration Elaboration}

The central parser transforms raw Lean syntax into a fully populated
\texttt{Config}. It operates in two phases: initialization with the label and
trace flag, followed by iteration over the option array with pattern matching
against 22 syntax variants.

\inputleannode{la:elab-blueprint-config}

\section{Node Assembly}

With the configuration parsed, the system assembles the final \texttt{Node}.
This process begins with determining whether the declaration warrants a separate
proof part, then constructs the statement and proof \texttt{NodePart} values,
and finally populates all 16 node fields.

The \texttt{hasProof} predicate implements a three-level priority: an explicit
user override takes precedence, followed by the presence of proof text, and
finally the declaration kind from the Lean environment.

\inputleannode{la:has-proof}

The statement part extracts the LaTeX text and statement-level dependency arrays
from the configuration. The LaTeX environment defaults to \texttt{theorem} for
declarations with proof parts and \texttt{definition} otherwise, but can be
overridden via the \texttt{latexEnv} option.

\inputleannode{la:mk-statement-part}

The proof part is analogous but uses the proof-level dependency arrays and
always sets the LaTeX environment to \texttt{proof}.

\inputleannode{la:mk-proof-part}

The \texttt{mkNode} function is where the annotation system's data model
crystallizes. It composes the above components into a complete \texttt{Node}
that is stored in the \texttt{blueprintExt} environment extension, making it
available to all downstream tools at build time.

\inputleannode{la:mk-node}

% =============================================================================
\chapter{Core Types}
% =============================================================================

The data structures defined in this chapter form the foundation upon which all
other LeanArchitect components are built. The three principal types---\texttt{NodeStatus},
\texttt{NodePart}, and \texttt{Node}---capture the full spectrum of information
that the blueprint system tracks for each annotated declaration.

\section{Node Status}

The six-level status hierarchy reflects formalization progress from initial
planning through to mathlib readiness. Three statuses are manually assignable
via attribute flags (\texttt{notReady}, \texttt{ready}, \texttt{mathlibReady}),
two are auto-detected from the proof term (\texttt{sorry} when the proof
contains \texttt{sorryAx}, \texttt{proven} when it does not), and one is
computed by graph traversal (\texttt{fullyProven}, when a node and all its
ancestors are proven). Each status maps to a distinct color in the dependency
graph visualization.

\inputleannode{la:node-status}

\section{Node Part}

A \texttt{NodePart} represents one component of a blueprint node---either
the statement or the proof. Each part carries its own LaTeX text, dependency
arrays (both by Lean name and by LaTeX label), exclusion arrays, and a
LaTeX environment specification. The separation of statement and proof
dependencies enables the dependency graph to distinguish logical dependencies
(dashed edges, from the statement's type) from implementation dependencies
(solid edges, from the proof term).

\inputleannode{la:node-part}

\section{Node}

The \texttt{Node} structure is the central data type of LeanArchitect. Its 16
fields cover four concerns: identity (\texttt{name}, \texttt{latexLabel}),
content (\texttt{statement}, \texttt{proof}, \texttt{above}, \texttt{below}),
status (\texttt{status}, \texttt{statusExplicit}), and project management
metadata (\texttt{title}, \texttt{keyDeclaration}, \texttt{message},
\texttt{priorityItem}, \texttt{blocked}, \texttt{potentialIssue},
\texttt{technicalDebt}, \texttt{misc}). Nodes are stored in the
\texttt{blueprintExt} environment extension and consumed by Dress for artifact
generation and by Runway for site rendering.

\inputleannode{la:node}

\section{Serialization Instances}

Nodes and their component types require serialization in three formats: JSON for
manifest files consumed by downstream tools, metaprogramming expressions for
storage in Lean's environment extensions, and backwards-compatible deserialization
for legacy data.

The JSON serialization maps each \texttt{NodeStatus} constructor to a canonical
lowercase string.

\inputleannode{la:node-status-to-json}

Deserialization accepts both canonical strings and legacy values from earlier
versions of the system. The strings \texttt{"stated"} and \texttt{"inMathlib"}
are silently mapped to their modern equivalents.

\inputleannode{la:node-status-from-json}

The \texttt{ToExpr} instance for \texttt{NodeStatus} is straightforward, mapping
each constructor to its corresponding \texttt{mkConst} application.

\inputleannode{la:node-status-to-expr}

The \texttt{ToExpr} instance for \texttt{Node} is notably manual rather than
derived. The derived \texttt{ToExpr} for structures with default-valued fields
produces incorrect expressions by omitting defaults, causing deserialization to
silently use wrong values. The manual instance ensures field-by-field fidelity
by explicitly serializing all 16 fields.

\inputleannode{la:node-to-expr}

The \texttt{notReady} predicate provides backwards compatibility for API
consumers that predate the six-status model.

\inputleannode{la:node-not-ready}

\section{Source Location Enrichment}

The \texttt{NodeWithPos} structure extends \texttt{Node} with source location
metadata, enabling downstream tools to map blueprint nodes back to their Lean
source files. This information is used for declaration ordering within modules
and for generating source links in the rendered output.

\inputleannode{la:node-with-pos}

The conversion from \texttt{Node} to \texttt{NodeWithPos} queries the Lean
environment for module indices, declaration ranges, and resolved file paths.

\inputleannode{la:node-to-node-with-pos}

\section{Label Registry}

Multiple Lean declarations may share a single LaTeX label---for instance, a
theorem and its corollary might both appear under the same node in the
dependency graph. The label registry maintains a persistent mapping from LaTeX
label strings to arrays of Lean constant names, supporting this many-to-one
relationship.

The state type is a sorted map from strings to name arrays.

\inputleannode{la:latex-label-state}

Each entry pairs a LaTeX label with a single Lean name.

\inputleannode{la:latex-label-entry}

Registration occurs during attribute elaboration.

\inputleannode{la:add-lean-name-of-latex-label}

Resolution is used by Dress during dependency graph construction to map
\texttt{usesLabels} references to actual Lean constants.

\inputleannode{la:get-lean-names-of-latex-label}

The \texttt{tryResolveConst} function resolves user-provided identifiers to
fully qualified Lean names, with configurable error recovery for forward
references during incremental formalization.

\inputleannode{la:try-resolve-const}

% =============================================================================
\chapter{Module Content and Commands}
% =============================================================================

A module's blueprint output is an ordered interleaving of annotated declarations
and module docstrings, preserving the author's intended narrative flow. This
chapter describes the sum type that models these content elements, the ordering
mechanism that sorts them by source position, and the retrieval APIs that make
content available to downstream tools.

\section{Blueprint Content Sum Type}

The \texttt{BlueprintContent} type is analogous to doc-gen4's
\texttt{ModuleMember}: it represents a single element in a module's blueprint
output, either an annotated declaration (wrapped in a \texttt{NodeWithPos}) or a
module docstring from a \texttt{blueprint\_comment} command.

\inputleannode{la:blueprint-content}

\section{Declaration Ordering}

Contents are sorted by their source position to maintain the narrative order the
author intended. The following two functions extract declaration ranges and
define the comparison order.

\inputleannode{la:blueprint-content-decl-range}

\inputleannode{la:blueprint-content-order}

\section{Retrieval APIs}

Two parallel APIs retrieve blueprint contents: one for the module currently
being elaborated (used during the \texttt{dressed} Lake facet), and one for
previously imported modules (used by Runway when rendering chapter pages).

The current-module retrieval is the primary entry point for Dress's per-module
artifact generation.

\inputleannode{la:get-main-module-blueprint-contents}

The imported-module retrieval operates on already-compiled modules via
\texttt{getModuleIdx?} and \texttt{getModuleEntries}.

\inputleannode{la:get-blueprint-contents}

\section{Module Docstrings}

The \texttt{blueprint\_comment} command allows authors to insert narrative
text between declarations. These docstrings are stored in a separate
environment extension and interleaved with declaration nodes during
content retrieval.

\inputleannode{la:add-main-module-blueprint-doc}

\inputleannode{la:get-main-module-blueprint-doc}

\inputleannode{la:get-module-blueprint-doc}

% =============================================================================
\chapter{Dependency Inference}
% =============================================================================

A central feature of LeanArchitect is automatic dependency inference: the system
analyzes the expression trees of annotated declarations to discover which other
blueprint nodes they reference. This avoids the error-prone process of manually
maintaining \texttt{\textbackslash uses\{\}} lists and ensures the dependency
graph accurately reflects the logical structure of the formalization.

The inference algorithm computes the irreflexive transitive closure of
blueprint-annotated dependencies reachable from a given constant. Blueprint
nodes serve as opaque boundaries: when the traversal encounters a constant with
a \texttt{@[blueprint]} annotation, it records it as a dependency and does not
recurse further. This ensures the dependency graph reflects the author's chosen
granularity rather than the full transitive closure of Lean's constant graph.

\section{The Monad Stack}

The traversal operates within a \texttt{ReaderT}/\texttt{StateM} monad stack
that provides read-only access to the Lean environment and the root declaration
name, along with mutable tracking of visited nodes and accumulated dependencies.

\inputleannode{la:collect-used-context}

\inputleannode{la:collect-used-state}

\inputleannode{la:collect-used-monad}

\section{The Recursive Traversal}

The core \texttt{collect} function performs a depth-first traversal of the
constant graph. For each constant $c$ encountered, it checks whether $c$ has
been visited (cycle prevention), whether $c$ has a \texttt{@[blueprint]}
annotation (boundary detection), and finally dispatches on the
\texttt{ConstantInfo} kind to determine which sub-expressions to recurse into.
Axioms are recorded directly as dependencies; definitions and theorems trigger
recursion into both their type and value expressions; constructors and recursors
recurse into their type only.

\inputleannode{la:collect-used-collect}

\section{The Top-Level API}

The \texttt{collectUsed} function is the public entry point. It runs the
traversal in two phases---first over the type expression (statement
dependencies) and then over the value expression (proof dependencies)---and
produces two disjoint \texttt{NameSet}s. Statement dependencies become dashed
edges in the dependency graph; proof dependencies become solid edges. The
exception is \texttt{sorryAx}, which may appear in both sets since its presence
in the proof is semantically significant regardless of whether it also appears
in the type.

\inputleannode{la:collect-used}

% =============================================================================
\chapter{Statement Validation}
% =============================================================================

LeanArchitect provides advisory validation of the LaTeX content in blueprint
statements. These checks catch common authoring errors---missing content,
unbalanced braces, mismatched math delimiters---before they propagate to
downstream rendering tools where the failure mode is typically a cryptic TeX
compilation error. All validation diagnostics are non-blocking warnings; they
never cause build failures.

The diagnostic type is a single-field wrapper around a warning message string.

\inputleannode{la:validation-diag}

The top-level validation entry point composes all checks into a single
diagnostic pass, short-circuiting on empty statements to avoid vacuous
downstream checks.

\inputleannode{la:validate-statement}

\section{Completeness Check}

The first validation gate verifies that the statement is non-empty after
trimming whitespace. If this check fails, subsequent checks are skipped to
avoid producing diagnostics about content that was never intended to be present.

\inputleannode{la:validate-completeness}

\section{Brace Balance}

LaTeX brace balancing uses recursive descent over the character list with an
integer depth counter. The implementation correctly handles escaped braces
(\texttt{\textbackslash\{} and \texttt{\textbackslash\}}) and escaped
backslashes (\texttt{\textbackslash\textbackslash}) preceding braces.

\inputleannode{la:validate-brace-balance}

\section{Math Delimiter Checking}

Inline math delimiters (\texttt{\$...\$}) are checked for even parity of
unescaped dollar signs. Display math delimiters
(\texttt{\textbackslash[...\textbackslash]}) are checked by independently
counting opening and closing occurrences. Escaped delimiters are correctly
excluded from the count.

\inputleannode{la:validate-math-delimiters}

% =============================================================================
\chapter{Cross-Reference Analysis}
% =============================================================================

Cross-reference analysis is a heuristic mechanism for detecting semantic drift
between a Lean type signature and its corresponding LaTeX statement. When a
formalization evolves---hypotheses are added, the conclusion changes, or the
algebraic context shifts---the informal statement may not be updated to
match. The cross-reference checker flags potential discrepancies as advisory
warnings, alerting the author that the LaTeX text may no longer accurately
describe the formalized result.

The analysis operates by decomposing both the Lean signature and the LaTeX
statement into comparable feature vectors, then applying three conservative
matching rules.

\section{Signature Decomposition}

The \texttt{SignatureComponents} structure captures the features extracted from a
Lean type by walking its $\forall$-telescope: quantified variable names and
types, hypothesis binders (identified by the \texttt{h}/\texttt{H} naming
convention), the conclusion type, and key algebraic identifiers filtered through
a curated list of 17 mathematical structure names.

\inputleannode{la:signature-components}

The extraction function iterates while \texttt{Expr.isForall} holds,
accumulating binders and collecting constant names from each binder type via
an iterative worklist traversal that avoids stack overflow on deeply nested
expressions.

\inputleannode{la:extract-signature-components}

\section{Statement Lexical Analysis}

The \texttt{StatementComponents} structure captures the linguistic features of
the LaTeX statement: math-mode identifiers, quantifier counts, and boolean flags
for implication, conjunction, and existential language. These features are
extracted by a state-machine parser that correctly handles escaped delimiters
and both inline and display math modes.

\inputleannode{la:statement-components}

\inputleannode{la:extract-statement-components}

\section{The Three-Rule Check}

The cross-reference check applies three conservative heuristic rules, each
designed to flag likely drift while minimizing false positives.

The \emph{math structure match} rule checks whether algebraic structures
mentioned in the Lean signature (e.g., \texttt{Group}, \texttt{Ring},
\texttt{TopologicalSpace}) appear in the LaTeX statement text. The
\emph{quantifier balance} rule flags cases where the Lean signature has five or
more quantified variables but the LaTeX statement contains no quantifier
language. The \emph{declaration name relevance} rule splits the Lean name by
underscores, filters to tokens longer than three characters not in a stop-word
list, and checks whether any appear in the statement.

\inputleannode{la:cross-ref-diag}

\inputleannode{la:cross-reference-check}

% =============================================================================
\chapter{Output Generation}
% =============================================================================

LeanArchitect produces two output formats: LaTeX files that define macros for
embedding node content in blueprint documents, and JSON files that expose
structured metadata to downstream tools. This chapter traces the complete output
pipeline from dependency resolution through rendering to filesystem I/O.

\section{LaTeX Foundations}

The output pipeline begins with foundational type aliases and utility functions
for LaTeX string manipulation.

\inputleannode{la:latex-abbrev}

Path normalization ensures correct \texttt{\textbackslash input} commands on
all platforms.

\inputleannode{la:latex-input}

The preprocessing pass is currently an identity function, serving as an
extension point for future LaTeX transformations.

\inputleannode{la:preprocess-latex}

\section{The InferredUses Pipeline}

The \texttt{InferredUses} structure bridges Lean's \texttt{NameSet}-based
dependency tracking and the LaTeX label system. Each \texttt{InferredUses} value
carries an array of LaTeX labels and a \texttt{leanOk} flag that is
\texttt{false} when the dependency set contains \texttt{sorryAx}.

\inputleannode{la:inferred-uses}

The empty and merge operations support the multi-declaration merging workflow
where several Lean declarations share a single LaTeX label.

\inputleannode{la:inferred-uses-empty}

\inputleannode{la:inferred-uses-merge}

Resolution of a single \texttt{NodePart}'s dependencies proceeds through a
seven-step pipeline: merge explicit and inferred uses, remove exclusions, map
Lean names to LaTeX labels, remove self-edges, add explicit label references,
remove label exclusions, and check for \texttt{sorryAx}.

\inputleannode{la:node-part-infer-uses}

At the node level, the \texttt{inferUses} function runs \texttt{collectUsed}
for Lean-level analysis and then resolves the results through
\texttt{NodePart.inferUses}, keeping statement and proof dependencies
separate.

\inputleannode{la:node-infer-uses}

\section{LaTeX Rendering}

The \texttt{NodePart.toLatex} function renders a single part as a complete
LaTeX environment block, including the \texttt{\textbackslash uses} command
(when dependencies are non-empty), the \texttt{\textbackslash leanok} marker
(when all backing declarations are sorry-free), and the body text.

\inputleannode{la:node-part-to-latex}

The \texttt{NodeWithPos.toLatex} function handles the full node, including
multi-declaration merging. When multiple Lean declarations share a LaTeX label,
their dependencies are merged and a single LaTeX block is emitted with combined
\texttt{\textbackslash lean} references, status annotations, and position data.

\inputleannode{la:node-with-pos-to-latex}

\section{Artifact and Output Structures}

Each rendered node produces a \texttt{LatexArtifact}: a pair of the LaTeX label
(used as the filename stem) and the rendered content.

\inputleannode{la:latex-artifact}

The complete output for a module is a \texttt{LatexOutput}, consisting of a
header function (which generates the preamble given an artifacts directory path)
and an array of per-node artifacts.

\inputleannode{la:latex-output}

Conversion from a positioned node to an artifact is a straightforward
composition.

\inputleannode{la:node-to-latex-artifact}

The \texttt{BlueprintContent.toLatex} function determines how each content
element appears in the header file: nodes emit \texttt{\textbackslash inputleannode}
commands, while module docstrings are inserted verbatim.

\inputleannode{la:blueprint-content-to-latex}

\section{The Macro System}

The LaTeX preamble defines four macros using \texttt{\textbackslash makeatletter}
that form the backbone of the blueprint document system:
\texttt{\textbackslash newleannode} and \texttt{\textbackslash inputleannode}
for per-declaration content, and \texttt{\textbackslash newleanmodule} and
\texttt{\textbackslash inputleanmodule} for per-module content. These macros
use global control sequences to defer content expansion, enabling forward
references within the document.

\inputleannode{la:latex-preamble}

\section{Module-Level Assembly}

Module-to-output conversion retrieves all blueprint contents from the
environment, deduplicates by LaTeX label, and renders each node to an
artifact. Separate functions handle imported modules and the currently
elaborating module.

\inputleannode{la:module-to-latex-output}

\inputleannode{la:main-module-to-latex-output}

\section{JSON Serialization}

The JSON output path provides structured metadata for downstream tools that
consume blueprint data programmatically rather than through TeX compilation.

\inputleannode{la:node-with-pos-to-json}

Each \texttt{BlueprintContent} element is serialized with a type tag
(\texttt{"node"} or \texttt{"moduleDoc"}) and its data payload.

\inputleannode{la:blueprint-content-to-json}

Module-level JSON conversion preserves declaration order within each module.

\inputleannode{la:module-to-json}

\inputleannode{la:main-module-to-json}

\section{Filesystem I/O}

The output functions write both LaTeX and JSON representations to the
filesystem, creating the directory structure expected by downstream build
phases.

Path computation maps Lean module names to filesystem paths using Lean's
\texttt{modToFilePath}.

\inputleannode{la:module-to-rel-path}

\inputleannode{la:library-to-rel-path}

The \texttt{outputLatexResults} function writes the complete module output:
a header file containing \texttt{\textbackslash newleannode} definitions, and
per-node artifact files in a sibling \texttt{.artifacts} directory.

\inputleannode{la:output-latex-results}

\inputleannode{la:output-json-results}

Library-level index files aggregate all modules in a library into a single
\texttt{\textbackslash input} chain (LaTeX) or module path array (JSON).

\inputleannode{la:output-library-latex}

\inputleannode{la:output-library-json}

% =============================================================================
\chapter{Integration Points}
% =============================================================================

LeanArchitect exposes several integration points that connect the annotation
system to external tools: an RPC endpoint for the VS Code infoview panel, a
proof docstring mechanism for tactic-level documentation, tactics for dependency
management within proofs, and an offline module loading system for batch
extraction.

\section{RPC Endpoint}

The \texttt{BlueprintInfo} structure is the data transfer object returned by the
RPC endpoint to the VS Code infoview panel. It projects the full \texttt{Node}
record into the subset of fields needed for live editor feedback: the constant
name, LaTeX label, status string, statement and proof text, dependency list, and
selected dashboard metadata. All string fields default to the empty string,
ensuring the infoview always receives a well-formed JSON payload.

\inputleannode{la:blueprint-info}

\section{Proof Docstrings}

The proof docstring system enables tactic-level documentation within proof
blocks. When a \texttt{/-- ... -/} comment precedes a tactic, the
\texttt{tacticDocComment} elaborator associates the text with the enclosing
declaration. These fragments are accumulated in a persistent environment
extension and concatenated to form the default proof text when no explicit
\texttt{proof := ...} option is provided in the attribute.

\inputleannode{la:proof-doc-string-state}

\inputleannode{la:proof-doc-string-entry}

\inputleannode{la:add-proof-doc-string}

\inputleannode{la:get-proof-doc-string}

\section{Offline Module Loading}

Batch-mode blueprint extraction requires loading Lean modules outside the
normal elaboration pipeline. The \texttt{envOfImports} function reconstructs a
full \texttt{Environment} from an array of module names, while
\texttt{runEnvOfImports} provides the standard execution wrapper with
appropriate performance settings (high heartbeat limit, kernel typechecking
disabled, async elaboration off).

\inputleannode{la:env-of-imports}

\inputleannode{la:run-env-of-imports}

These functions compose with the output generators to produce per-module LaTeX
and JSON from imported modules.

\inputleannode{la:latex-output-of-import-module}

\inputleannode{la:json-of-import-module}

% =============================================================================
\chapter{Design Rationale}
% =============================================================================

This chapter discusses the key design decisions in LeanArchitect and their
motivations.

\section{Attribute-Based Annotation}

LeanArchitect uses Lean's attribute system rather than delimiter-based
annotation (e.g., special comments or preprocessing directives). Attributes
are first-class citizens of the Lean elaboration pipeline: they have access to
the full \texttt{Environment}, they can query type information, and they
participate in incremental compilation. This enables features that would be
impossible with text-based approaches, such as automatic dependency inference
from proof terms and type-checked constant references in \texttt{uses} clauses.

The tradeoff is that annotations must be syntactically valid Lean, which
constrains the surface syntax. In practice, the use of doc-comment strings
(\texttt{/-- ... -/}) for LaTeX content provides a natural embedding that
supports arbitrary LaTeX without escaping.

\section{The Six-Status Hierarchy}

A binary ready/not-ready model is insufficient for tracking formalization
progress. The six-status model (\texttt{notReady}, \texttt{ready},
\texttt{sorry}, \texttt{proven}, \texttt{fullyProven}, \texttt{mathlibReady})
captures the meaningful stages of a declaration's lifecycle:

\begin{itemize}
  \item \texttt{notReady} and \texttt{ready} are manually assigned by the
    author, reflecting planning status before formalization begins.
  \item \texttt{sorry} and \texttt{proven} are auto-detected from the proof
    term, providing ground truth about the current formalization state.
  \item \texttt{fullyProven} is computed by graph traversal, identifying
    declarations whose entire dependency subtree is sorry-free.
  \item \texttt{mathlibReady} is manually assigned, marking declarations ready
    for upstream contribution.
\end{itemize}

The status priority order ensures that auto-detected information takes precedence
over manual defaults but that explicit manual overrides (\texttt{mathlibReady},
\texttt{ready}) can still be applied.

\section{Advisory Validation}

Validation diagnostics are warnings, never errors. This design ensures that
blueprint annotations never break builds. An incomplete or malformed LaTeX
statement should not prevent a mathematician from compiling their Lean code.
The warnings serve as gentle nudges to maintain quality in the informal content,
without imposing a hard gate on the formal development workflow.

\section{Heuristic Cross-Reference}

The cross-reference analysis is deliberately heuristic rather than semantic.
A precise comparison between a Lean type and its LaTeX description would require
either natural language understanding or a formal mapping between the two---both
beyond the scope of a build-time check. The three-rule approach (math structure
match, quantifier balance, declaration name relevance) catches the most common
forms of drift with minimal false positives. The high thresholds (e.g., $\geq 5$
quantified variables for the quantifier check) are calibrated to avoid noise
from standard implicit-binder-heavy Lean signatures.

\section{Manual \texttt{ToExpr}}

The \texttt{ToExpr Node} instance is hand-written rather than derived. Lean 4's
derived \texttt{ToExpr} for structures with default-valued fields omits those
defaults, producing expressions that, when deserialized, silently use the
wrong values. For \texttt{Node}, where fields like \texttt{status} and
\texttt{statusExplicit} have defaults that carry semantic meaning, this would
cause status information to be lost during elaboration. The manual instance
guarantees field-by-field fidelity at the cost of maintenance burden when
fields are added.

\section{The Wrapper Project Approach}

This document is produced by a wrapper project
(\texttt{LeanArchitect-Blueprint}) that \texttt{import}s LeanArchitect and
applies retroactive \texttt{@[blueprint]} annotations to its declarations.
This approach is necessary because Lean 4's \texttt{afterCompilation}
attribute hooks cannot be used on declarations within the same package---the
IR interpreter crashes when attempting to evaluate code that is still being
compiled. The wrapper project provides a clean compilation boundary: by the
time annotations are applied, all LeanArchitect code is fully compiled and
available for introspection.

This is the same pattern used by any project that annotates third-party
library declarations with \texttt{@[blueprint]}. The fact that LeanArchitect
must use it on itself is a fitting demonstration of both the pattern's utility
and its necessity.

\end{document}
